#!/usr/bin/env python'''name: 01_对象表示形式 author: li zhangdate: 2019/10/28'''# 得益于python的数据模型，自定义类型的行为可以像内置类型那样自然，实现如此自然的行为，靠的不是继承，而是鸭子类型。from array import arrayimport mathclass Vector2d:    typecode = 'd'    def __init__(self,x,y):        self.x = x        self.y = y    def __iter__(self):        return (i for i in (self.x, self.y))    def __repr__(self):        class_name = type(self).__name__        return '{}({!r}, {!r})'.format(class_name, *self)    def __str__(self):        return str(tuple(self))    def __bytes__(self):        return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))    def __eq__(self, other):        return tuple(self) == tuple(other)    def __abs__(self):        return math.hypot(self.x, self.y)    def __bool__(self):        return bool(abs(self))v1 = Vector2d(3,4)print(v1.x, v1.y)x, y = v1v1_clone = eval(repr(v1))'''class method static method '''# 定义操作类，而不是操作实例的方法，改变了调用方法的方式# 有些难以理解，是非常难以理解，需要大量的实践来get其中的作用# 所以python是怎么调用底层函数的，是怎么实现的