#!/usr/bin/env python'''name: 1_f防御可变参数 author: li zhangdate: 2019/10/24'''# 可变参数class HauntedBus:    """备受幽灵乘客折磨的校车"""    def __init__(self, passengers=[]):        self.passengers = passengers    def pick(self, name):        self.passengers.append(name)    def drop(self, name):        self.passengers.remove(name)# 新建对象时，会同时passengers会同时指向list# DEL和垃圾回收# 垃圾回收使用的主要算法是引用计数# del删除的不是对象，是对象的引用import weakrefs1 = [1,2,3]s2 = s1def bye():    print('Gone with the wind...')# ender = weakref.finalize(s1, bye)# print(ender.alive)# del s1# print(ender.alive)# s2 = ['spam']# print(ender.alive)# 弱引用# 弱引用不会增加对象的引用数量，因为我们不想仅因为被缓存引用着而始终保存缓存对象a_set = {0,1}wref = weakref.ref(a_set)  # 创建弱引用对象wref,print(wref)import weakrefclass Cheese:    def __init__(self, kind):        self.kind = kind    def __repr__(self):        return 'Cheese(%r)' % self.kindstock = weakref.WeakValueDictionary()catalog = [Cheese('Red Leicester'), Cheese('Tilsit'), Cheese('Brie'), Cheese('Parmesan')]for cheese in catalog:    stock[cheese.kind] = cheesesorted(stock.keys())del catalogsorted(stock.keys())del cheesesorted(stock.keys())print(2)# python 的引用模型# 增量赋值，对于可变对象的引用就地改变，对于不可变对象的引用，可能会创建一个新的对象，取决于是否改变他的大小。# python 对象的生命周期根据引用对象的个数来进行判断，当对象的引用个数为0时，对象被销毁。特别的，弱引用不计算到引用对象的个数中。# 即对一个对象创建弱引用，他的引用计数不会增加。