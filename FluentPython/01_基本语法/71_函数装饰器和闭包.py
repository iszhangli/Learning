#!/usr/bin/env python'''name: 71_函数装饰器和闭包 author: li zhangdate: 2019/9/21'''# 闭包是回调式异步编程 和 函数式编程风格 的基础# 注册装饰器和参数化装饰器# 装饰器是可调用的对象，参数是另一个函数(被装饰的函数)def decorate(func):    return func@decoratedef target():    print('running target')# target()# 装饰器的一大特性是，能把被装饰的函数代替成其他函数# 装饰器在加载模块时立即执行# 2. python何时执行装饰器registry = []# 函数装饰器在导入模块的时候回立即执行，执行装饰器函数，不是被装饰的函数def register(func):    print('running register(%s)' % func)    registry.append(func)    return func@registerdef f1():    print('running f1()')@registerdef f2():    print('running f2()')def f3():    print('running f3()')# 装饰器通常在一个模块中定义，然后应用到其他模块的函数上# 大多数装饰器会在内部定义一个函数，然后将其返回# 使用装饰器改进策略模式promos = [] # 把函数注册一下，用的时候可选择，统一用def promotion(promo_func):    promos.append(promo_func)    return promo_func@promotiondef fidelity(order):    '''为积分1000或者以上的顾客提供5%折扣'''    return order.total() * .05 if order.customer.fidelity >= 1000 else 0# 注册器使用1：将所有的函数都加载一遍，然后可选择的使用# 7.4 变量作用域规则b = 6def f4(a):    print(a)    print(b)    b = 0f4(2)def main():    print('running main()')    print('registry -> ', registry)    f1()    f2()    f3()if __name__ == '__main__':    main()