# !/usr/bin/env python# -*- coding:utf-8 -*-# name: 01_迭代 # author: li zhang# date: 2019/11/25# 迭代器模式: 按需一次获取一个数据项# 加入了yield关键字，这个关键字用于构建生成器# 迭代器用于从集合中取出元素，生成器生成不存在的数据# 在python中，所有的集合都可以迭代import reimport reprlibRE_WORD = re.compile('\w+') # w匹配非特殊字符，+ 匹配一次或者多次print(RE_WORD)class Sentence(object):    def __init__(self, text):        self.text = text        self.words = RE_WORD.findall(text)        print('words:', self.words)    def __getitem__(self, item):        return self.words[item]    def __len__(self):        return len(self.words)    def __repr__(self):  # 转换成供解释器可以解释的格式        return 'Sentence(%s)' % reprlib.repr(self.text)s = Sentence('The time has come, the Walrus said')print(s)for word in s:    print(word)print(s[0])# 解释器可以迭代的原因是iter函数，# 1. 检查对象是否实现了iter方法，如果实现了就调用它，获取一个迭代器# 2. 如果没有实现iter, 但是实现了getitem方法，python会创建一个迭代器# 任何python序列可迭代的原因是实现了 getitem方法# 可迭代的对象和迭代器的对比# python从可迭代的对象中获取迭代器s = 'ABC'it = iter(s)# while True:#     print(next(it))# python 内部会处理for循环和其他迭代上下文中的stop iterations3 = Sentence('Pig and Peper')it = iter(s3)for i in it:    print(i)print(it)# Iterator.__iter__ 方法的实现方式是# 返回实例本身， 所以传入迭代器无法还原已经耗尽的迭代器print('next', next(it))print(list(it))  # next一次后，it迭代器中少了被迭代的部分