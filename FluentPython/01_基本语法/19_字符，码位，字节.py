#!/usr/bin/env python'''name: 19author: li zhangdate: 2019/9/19'''# 汉字有几个字节组成# python3不可变的bytes类型cafe = bytes('caf①', encoding='utf-8')print(cafe)print(cafe[0]) # 编码后是0-255的数字,区别在于返回一个对象print(cafe[:1]) # bytes对象的切片依然是bytes对象，即使是一个字节，返回一个切片cafe_arr = bytearray(cafe)print(cafe_arr)print(cafe_arr[-1:])# 除了格式化和处理unicode的方法# 结构体和内存视图# struct 和 memoryview# 文本和字节的转换for codec in ['latin-1', 'utf-8', 'utf-16']:    print(codec, 'E1 Niβ'.encode(codec, errors='replace'), sep='\t', end='\n')# 处理unicodeEncodeError的问题# 当编码集中没有定义字符时，编码时会产生这种错误# encode('', errors='replace')# 处理unicodeDecodeErrorkoctets = b'Montr\xe9al'de = octets.decode('utf-8', errors='replace')print(de, sep='\t', end='\n')# python3开始使用utf-8 python2(2.5开始)使用ASCII# 有类似的字符编码侦测包 chardet# 大字节编码 / 小字节编码 小字节的UTF16编码前面有BOM(byte order maker 鬼码)# python 处理文本文件# unicode 三明治模型，这个在输出的模型# open() 必要的解码（预处理）open('cafe.txt', 'w', encoding='utf-8').write('caf①')data = open('cafe.txt', encoding='utf-8').read() # 如果不指定的话会报错，这windows上默认的编码方式是windows1252print(data)# 好的建议就是开发过程中显示指定编码方式，不依赖随机的运气# 正确比较规范化unicode字符串from unicodedata import normalizes1 = 'café's2 = 'cafe\u0301' # combining acute accentprint(len(s1), len(s2), sep='\t')print(normalize('NFD', s1))print(normalize('NFC', s1) == normalize('NFC', s2))print(normalize('NFD', s1) == normalize('NFD', s2))# 规范化文本匹配使用函数# NFC and NFD# str.casefold()# nfc_equal fold_equaldef nfc_equal(str1, str2):    return normalize('NFC', str1) == normalize('NFC', str2)def fold_equal(str1, str2):    return normalize('NFC', str1).casefold() == normalize('NFC', str2).casefold()# unicode中的文本排序# 非ASCII文本的标准排序方式是使用locale.strxfrm函数# 使用unicode的排序算法进行排序# pyuca 进行排序# 正则表达式中的字符串和字节序列import rere_numbers_str = re.compile(r'\d+')re_words_str = re.compile(r'\w+')re_numbers_bytes = re.compile(rb'\d+')re_words_bytes = re.compile(rb'\w+')text_str = ("Ramanujan saw \u0be7\u0bed\u0be8\u0bef" " as 1729 = 1³ + 12³ = 9³ + 10³.")text_bytes = text_str.encode('utf-8')print(text_bytes)print('Text', repr(text_str), sep='\n')